Some thoughts
-------------

type mngt_contract =
      {start: date,
       initial: contract,
       date: date,
       current: contract,
       events: event list}    //   (start, initial)   ---events---> (date, current)

datatype event =  Fixing of date * string * value | NewContract of date * ContractTypes.contract | Default of date * string

datatype portfolio = {start   : date,
                      initial : contract,
                      events: event list,
                      current_date: date,
                      current : contract}

===================

Semantics of translating a contract: should affect embedded expressions/observables!

i = If (condition(day) , contract1, contract2)
Transl (I 30 , i ) =!= If (condition ( day + 30 ) , 
                           Transl (I 30, contract1), 
                           Transl (I 30, contract2)

-------------
Preconditions: causality of components

consistent (a : contract) : bool
   (no flow in the present depends on future value of any observable,
    and this is maintained through translated contracts)

This implies the following side conditions:
o Obs of String * int: int should be non-positive
                       if a positive int occurs, an _outer_ Transl must be introduced 
                       to eliminate it*).
o Transl of intE * contract: intE should _evaluate_ _to_ non-negative number

Transl nodes should be pushed to the outside in normalisation
(direction "<=" in the example above). If this yields negative Transl
on the inside, the contract is not consistent.
Question here is, how to check this, as Transl uses intE, not int.

=====================

Ideas how to use this library in the future:

fun normalise (a : contract) = beautiful contract
fun isBarrier (a : contract) = ...pattern match..
fun defocus ( a : contract, days : int ) = contract aggregating "day windows"
    should be called "decreaseLevelOfDetail", or something else?

makes possible to do: 
  testB  a = isBarrier (normalise (defocus ( a , 1week)))

-------------

simpler uses, immediately possible:

removeParty (p : string, a : contract) = contract without anything involving party p
mergeParties (p1, p2 : string, a : contract) = contract with party p2 identified with p1

more real-world functionality:

defaultParty (party : string, 
             t : time (expected litigation duration), 
             perc : real (percentage), a : contract) = 
      contract a, with all transactions involving party scaled to
      perc % and translated by time t forward

=======================

How to model (non-rational) choice?

Should be part of the Expr language (chosenBy party : boolE) and 
use the If constructor.

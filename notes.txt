Some thoughts
-------------

type mngt_contract =
      {start: date,
       initial: contract,
       date: date,
       current: contract,
       events: event list}    //   (start, initial)   ---events---> (date, current)

datatype event =  Fixing of date * string * value | NewContract of date * ContractTypes.contract | Default of date * string

datatype portfolio = {start   : date,
                      initial : contract,
                      events: event list,
                      current_date: date,
                      current : contract}

===================

Semantics of translating a contract: should affect embedded expressions/observables!

i = If (condition(day) , contract1, contract2)
Transl (I 30 , i ) =!= If (condition ( day + 30 ) , 
                           Transl (I 30, contract1), 
                           Transl (I 30, contract2)

-------------
Preconditions: causality of components

consistent (a : contract) : bool
   (no flow in the present depends on future value of any observable,
    and this is maintained through translated contracts)

This implies the following side conditions:
o Obs of String * int: int should be non-positive
                       if a positive int occurs, an _outer_ Transl must be introduced 
                       to eliminate it*).
o Transl of intE * contract: intE should _evaluate_ _to_ non-negative number

Transl nodes should be pushed to the outside in normalisation
(direction "<=" in the example above). If this yields negative Transl
on the inside, the contract is not consistent.
Question here is, how to check this, as Transl uses intE, not int.

=====================

Ideas how to use this library in the future:

fun normalise (a : contract) = beautiful contract
fun isBarrier (a : contract) = ...pattern match..
fun defocus ( a : contract, days : int ) = contract aggregating "day windows"
    should be called "decreaseLevelOfDetail", or something else?

makes possible to do: 
  testB  a = isBarrier (normalise (defocus ( a , 1week)))

-------------

"beautiful contract" (normal form): established by a special routine.
Should gather constructors in one place, essentially on one
side of If and CheckWithin constructs: Transl should be pushed to the
outside, Scale should be pushed in. All should be inside, but above 
Scale (to see empty leaves?)
In addition, should apply simplifications once constructors are
adjacent: multiply Scales, add Transl, cut them when empty below

======================

simpler uses, immediately possible:

removeParty (p : string, a : contract) = contract without anything involving party p
mergeParties (p1, p2 : string, a : contract) = contract with party p2 identified with p1

more real-world functionality:

defaultParty (party : string, 
             t : time (expected litigation duration), 
             perc : real (percentage), a : contract) = 
      contract a, with all transactions involving party scaled to
      perc % and translated by time t forward

=======================

How to model (non-rational) choice?

Should be part of the Expr language (chosenBy party : boolE) and 
use the If constructor.

=======================

How the contract language differs from the LexiFi contract language

 - Dates are first class, meaning that a residual contract can be
   translated in time a dynamic amount (e.g., based on an
   underlying). American optionality and knock-outs are therefore
   easily expressible, without discretization; we may need a few more
   operators, such as anytime, however.

 - Contracts are truly relative to the present, which is contrary to
   how the LexiFi system works. In the LexiFi system, observables are
   defined separately and are not translated in time by the 'when'
   operator; see "The Fun of Programming" paper, page 114, for
   instance. Also, the paper does not mention whether there is a
   "delay" operator that allows for a contract to refer to a past
   value of an underlying.

 - Concrete contracts are paired with an associated date under which
   the contract should be understood. Using this date, cash flows with
   concrete dates can be computed. The notion of advancing a contract
   is important. Say we have a concrete contract (d,c), that is a
   contract c that should be understood relative to the date d. We
   have (d,c) -adv(1)-> (d+1,c'), where c' is c advanced by one
   day. First notice that expressions in the contract language are
   arithmetic and boolean expressions that may reference underlying
   observable quantities at particular dates, relative to
   now. Formally, we first define the notion of expression time
   adjustment:

   Expression Time Adjustment
    (s,d)/d' = (s,d+d')
    e/d' = e with all underlying references (s,d) in e replaced by (s,d+d')

   Notice that time adjustment e/d is defined only when d is known to
   be a particular integer.

   Here are some equivalences that hold:

    transl(d1,transl(d2,c)     ==   transl(d1+(d2/d1),c)           d1 certain
    transl(d,scale(s,c))       ==   scale(s,transl(d,c))           s certain
    transl(d,scale(s,c))       ==   scale(s/d,transl(d,c))         d certain
    scale(s1,scale(s2,c))      ==   scale(s1*s2,c)
    iff(T,c1,c2)               ==   c1
    iff(F,c1,c2)               ==   c2
    transl(d,all cs)           ==   all (map (\c.transl(d,c)) cs)
    transl(d,iff(cond,c1,c2))  ==   iff(cond/d, transl(d,c1), transl(d,c2))   d certain
    iff(c,emp,emp)             ==   emp
    transl(d,emp)              ==   emp
    scale(r,emp)               ==   emp
    all cs                     ==   emp             forall c in cs. c == emp
    scale(0,c)                 ==   emp

   Advancing a contract (throwing away due transfers) can now be
   defined, formally (and partially), as follows:

    fun adv 0 c = c
      | adv n c =         (* notice: n >= 0 *)
        case c of
           scale(s,c) => scale(s/-n, adv n c)
         | transl(d,c) => 
              if certain d then
                  let n' = min n d
                  in transl(d-n', adv (n-n') c)
                  end
              else error "contract advancement not possible"
         | transl(d,c) => 
         | iff(cond,c1,c2) => iff(cond/-n,adv n c1,adv n c2)
         | all cs => all (map (adv n) cs)
         | transfOne(c,p1,p2) => emp
 
   It is not clear whether we can always write up a contract in a
   canonical form that will help us determine whether two contracts
   are bisimilar.

 - A causal contract is, by definition, a contract with the property that during all
   possible executions of the contract, a transfer cannot depend on a
   future fixing.

   Example of a non-causal contract:

      iff(("CarlsbergDKR",2) > 50.0, transfOne(EUR,me,you), emp)

         - Meaning: if the Carlsberg stock is worth more than kr 50 in
           two days, I should transfer one EUR to you today.

In general, causality is now a dynamic property that for some
contracts needs to be checked at runtime (during contract
management). For many contracts, however, the property of causality
can be established statically. We now define a conservative causality
check. An expression e is causal (written |- e), if for all (s,d) in
e, we have d <= 0. That is, the valuation of the expression depends
only on values for underlyings in the past. A conservative causality
check can now be defined for contracts, as follows.
 
                                                           +------+
Conservative contract causality                            | |- c |
                                                           +------+
       certain(d)  d >= 0    |- c/d
       ---------------------------- (TL1)
            |- transl(d,c)

          |- d    |- c
         -------------- (TL2)
         |- transl(d,c)

         --------------------- (TO)
         |- transfOne(C,p1,p2)

         |- e   |- c
        ------------- (Sc)
        |- scale(e,c)

        |- e  |- c1  |- c2
        ------------------ (If)
         |- iff(e,c1,c2)

          |- ci    i=1..n
        ------------------- (Al)
        |- all [c1,....,cn]

Proposition (Conservative Causality Soundness).
If |- c then c is causal. 

=======================

Design question:

 Should transl affect the date on which an underlying is referenced?

 - The answer to this question is yes! Otherwise, we would lack good
   compositionality properties.


h([],a) = a
h(c::cs,a)  = h(cs, c + a * 19)

val hashExp:  expr0 -> IntInf.int
val hashContr : contr -> IntInf.int

h(Zero, a)                 = 2 * a
h(Both(c1,c2), a)          = h(c1,0) + h(c2,0) + a
h(TransfOne(cur,p1,p2), a) = 3 * h(cur,h(p1,h(p2,a)))
h(Iff(e,c1,c2),a)          = 5 * h(c1,h(c2,h(e,a)))
h(Scale(e,c),a)            = 7 * h(e,h(c,a))
h(Transl(e,c),a)           = 11 * h(e,h(c,a))


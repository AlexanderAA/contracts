Some thoughts
-------------

type mngt_contract =
      {start: date,
       initial: contract,
       date: date,
       current: contract,
       events: event list}    //   (start, initial)   ---events---> (date, current)

datatype event =  Fixing of date * string * value | NewContract of date * ContractTypes.contract | Default of date * string

datatype portfolio = {start   : date,
                      initial : contract,
                      events: event list,
                      current_date: date,
                      current : contract}

===================

Semantics of tranlating a contract: should affect embedded expressions/observables!

i = If (condition(day) , contract1, contract2)
Transl (I 30 , i ) =!= If (condition ( day + 30 ) , 
                           Transl (I 30, contract1), 
                           Transl (I 30, contract2)

TODO transform ContractUtils according to above

=====================

Ideas how to use this library in the future:

fun normalise (a : contract) = beautiful contract
fun isBarrier (a : contract) = ...pattern match..
fun defocus ( a : contract, days : int ) = contract aggregating "day windows"
    should be called "decreaseLevelOfDetail", or something else?

makes possible to do: 
  testB  a = isBarrier (normalise (defocus ( a , 1week)))

-------------

simpler uses, immediately possible:

removeParty (p : string, a : contract) = contract without anything involving party p
mergeParties (p1, p2 : string, a : contract) = contract with party p2 identified with p1

more real-world functionality:

defaultParty (party : string, 
             t : time (expected litigation duration), 
             perc : real (percentage), a : contract) = 
      contract a, with all transactions involving party scaled to
      perc % and translated by time t forward

=======================

How to model (non-rational) choice?

Should be part of the Expr language (chosenBy party : boolE) and 
use the If constructor.

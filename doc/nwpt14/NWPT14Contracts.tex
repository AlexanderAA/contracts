\documentclass[a4paper,debug,twocolumn]{easychair}
%\documentclass[a4paper,debug]{easychair}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
%\usepackage{graphicx}
\usepackage{xcolor}

\newcommand{\comm}[3][red]{{\small \color{#1}{$\spadesuit$#2: #3}}}
%\renewcommand{\comm}[3][]{}
\newcommand{\jbcomment}[1]{\comm[orange]{jb}{#1}}
\newcommand{\pbcomment}[1]{\comm[green]{pb}{#1}}
\newcommand{\mecomment}[1]{\comm[magenta]{me}{#1}}

\newcommand\type[1]{\mathsf{#1}}
\newcommand\reals{{\mathbb R}}
\newcommand\nats{{\mathbb N}}
\newcommand\ints{{\mathbb Z}}
\newcommand\pto{\rightharpoonup}
\newcommand\cSem[2]{{\mathcal C}\left\llbracket#1\right\rrbracket_{#2}}

\newcommand\cRed[2]{\stackrel{#2}\Rightarrow_{#1}}
\newcommand\cRedFun{f_{\Rightarrow}}
\newcommand\envAdv[1]{#1\uparrow}
\newcommand\Pred[1]{\textsc{#1}}

\theoremstyle{plain} 
\newtheorem{theorem}{Theorem} 

\begin{document}

\title{Towards Certified Management of Financial Contracts
\thanks{Work partially supported by DSF grant No.\jbcomment{yaddayadda} (\textsc{Hiperfit})}}

\titlerunning{Towards Certified Management of Financial Contracts}

\author{Patrick Bahr
    \and
        Jost Berthold 
    \and 
        Martin Elsman 
    \and 
        Fritz Henglein\\
}

\institute{University of Copenhagen\\
    Dept. of Computer Science (DIKU)\\
    \email{\{paba,berthold,mael,henglein\}@di.ku.dk}\\
}

\authorrunning{Bahr, Berthold, Elsman, Henglein}

\clearpage
\maketitle

\section{Introduction}

Financial computations are among the domains where (embedded) Domain specific
languages (EDSLs) first came into widespread use.
The seminal work on modelling derivatives by Peyton-Jones and Eber~\cite{SPJ2000}
demonstrated the usefulness of DSLs for financial software.
%
Eber's company \emph{LexiFi}, a leading software provider
for financial institutions, has designed their entire software portfolio
around contract language MLFi~\cite{MLFi} (ML for finance).

What was a complete novelty in 2000 has become common-place since.
Today, many banks and financial software providers use contract DSLs internally
which follow their first design to some extent.
However, the in-house languages we have encountered within our work in project
\textsc{Hiperfit}~\cite{TFP11Hiperfit} are sometimes disappointing with respect
to what could be achieved.
%
Some contract languages are used to ease pay-out batch processing and suffer
from unfavourable data models when used for pricing.
%
Other languages are used mainly for pricing and valuation, and contain many
bolted-on extensions for bespoke stochastic models and in-house pricing
software, which get in the way of readability and symbolic contract processing.
\jbcomment{tone down? how to substantiate it?}


In this paper, we present a small simple contract language which rigorously
relegates any artefacts of modelling and computation from its core, and show
that plenty of information can be derived from, and useful manipulations defined
on, just the symbolic contract specification, independent of any stochastic
aspects of the modelled contracts.
Contracts modelled in our language can be analysed and transformed for their
management according to a precise cash-flow semantics, modelled and checked
using proof assistant Coq.

\section{Contract Language}
\label{sec:contract-language}

\subsection{Example}
\label{sec:example}

\subsection{Denotational Semantics}
\label{sec:semantics}

We define a denotational semantics by mapping contracts to cash flows,
which are partial functions from time to transfers between two
parties:
\begin{align*}
  \type{Trans} &= \type{Party} \times \type{Party} \times
  \type{Currency} \to \reals\\
  \type{Flow} &= \nats \pto \type{Trans}
\end{align*}

The cash flow is a partial mapping since it may not be determined due
to insufficient knowledge about the observables. The semantics of
contracts depends on the valuation of observables, which is given by
an environment:
\begin{align*}
  \type{Env} &= \ints \times \type{Observable} \pto A\\
  \cSem{\cdot}{\cdot}&\colon \type{Contract} \times \type{Env} \to
  \type{Flow}
\end{align*}

This denotational semantics is the foundation for the formalisation of
symbolic contract analyses, contract management and contract
transformations.

An important property of the semantics of contracts is monotonicity,
which is the property that
\[
\cSem c {\rho_1} \subseteq \cSem c {\rho_2} \text{ if }
\rho_1\subseteq \rho_2
\]
where $\subseteq$ denotes the subset inclusion of the graph of two
partial functions.

\subsection{Contract Analysis}
\label{sec:contract-analysis}

When deaing with contracts we are interested in a number of properties
such as causality (Does the cash-flow at each time $t$ depend only on
observables at time $\leq t$?), horizon (From which time onwards is
the cash-flow always zero?) and dependencies (Which observables does
the cash-flow depend on?). Such properties can be characterised
precisely using the denotational semantics. For example a contract $c$
is causal iff for all $t \in \nats$, we have that
\[
\cSem c{\rho_1} (t) = \cSem c {\rho_2} (t) \text{ if } \forall s \le t\colon
\rho_1(s)=\rho_2(s)
\]


Deciding these properties precisely is in general undecidable but we
can provide conservative approximations.  For instance we have an
inductively defined predicate $\Pred{Causal}$ such that if
$\Pred{Causal}(c)$, then $c$ is indeed causal. This is not unlike type
checking, which provides a conservative approximation of type safety.


\section{Contract Management and Transformation}
\label{sec:contract-management}

\pbcomment{What do we precisely mean by contract management?}

Apart from a variety of analyses our framework provides functionality
to transform contracts in meaningful ways. The most basic form of such
transformations are provided by algebraic laws. These laws of the form
$c_1 \equiv c_2$ state when it is safe to replace a contract $c_1$ by
a contract $c_2$. Using our denotational semantics, these algebraic
laws can be proved in a straightforward manner: we have $c_1 \equiv
c_2$ iff $\cSem{c_1}\rho = \cSem{c_2}\rho$ for all $\rho \in
\type{Env}$.

More interesting are transformations that are based on knowledge about
observables. That is, we transform a contract $c$ based on an
environment $\rho \in \type{Env}$ that encodes the knowledge that we
already have. We consider two examples, specialisation and reduction.

\subsection{Specialisation}
\label{sec:specialisation}

A specialisation function $f$ takes a contract and an environment and
returns a contract that is equivalent under the given
environment. That is,
\[
\cSem{f(c,\rho)}\rho = \cSem c \rho
\]

Since $f$ specialises the contract $c$ to the environment $\rho$, one
would hope to get the stronger property $\cSem{f(c,\rho)}\emptyset =
\cSem c \rho$. However, in general this is not possible.

\subsection{Reduction Semantics}
\label{sec:reduction-semantics}


Apart from the denotational semantics our contract language is also
equipped with a reduction semantics, which advances a contract by one
time unit. We write $c \cRed \rho \tau c'$, to denote that $c$ is
advanced to $c'$ in the environment $\rho$, where $\tau \in
\type{Trans}$ indicates the transfers that are necessary (and
sufficient) in order to advance $c$ to $c'$.

The reduction semantics can be implemented as a recursive function of
type 
\[
\cRedFun \colon\type{Contract}\times \type{Env} \pto \type{Contract} \times \type{Trans}
\]
$\cRedFun$ takes a contract $c$ and an environment $\rho$, and returns
the residual contract $c'$ and the transfers $\tau$ such that $c
\cRed\rho\tau c'$. The argument $\rho$ typically contains the
knowledge that we have about the observables up to the present time,
i.e.\ for time points $\leq 0$.

We can show that the operational semantics is sound w.r.t.\ the
denotational semantics:
\begin{theorem}
  If $c \cRed\rho\tau c'$, then $\cSem c {\rho} (0) = \tau$ and $\cSem
  c {\rho} (i+1) = \cSem{c'}{\envAdv{\rho}}(i)$ for all $i \in \nats$,
  where $\envAdv{\rho} (i) = \rho(i+1)$. If there are no $c', \tau$
  with $c \cRed\rho\tau c'$, then $\cSem c \rho (0)$ is undefined.
\end{theorem}



\subsection{Implementation}
\label{sec:implementation}

Implementation as a Haskell EDSL

\section{Discussion and Future Work}
\label{sec:disc-future-work}

Future work:
\begin{itemize}
\item more extensive analyses (e.g. ``zooming'', scenario generation)
\item code generation for pay-off function for pricing frameworks
\end{itemize}





\bibliographystyle{abbrv}
\bibliography{NWPT14Contracts}

\end{document}